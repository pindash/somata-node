// Generated by CoffeeScript 1.11.1
(function() {
  var CONNECTION_LINGER_MS, CONNECTION_RETRY_MS, Client, Connection, EventEmitter, REGISTRY_HOST, REGISTRY_PORT, REGISTRY_PROTO, VERBOSE, emitters, helpers, log,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Connection = require('./connection');

  EventEmitter = require('events').EventEmitter;

  helpers = require('./helpers');

  log = helpers.log;

  emitters = require('./events');

  VERBOSE = parseInt(process.env.SOMATA_VERBOSE || 0);

  REGISTRY_PROTO = process.env.SOMATA_REGISTRY_PROTO || 'tcp';

  REGISTRY_HOST = process.env.SOMATA_REGISTRY_HOST || '127.0.0.1';

  REGISTRY_PORT = process.env.SOMATA_REGISTRY_PORT || 8420;

  CONNECTION_LINGER_MS = 1500;

  CONNECTION_RETRY_MS = 2500;

  Client = (function(superClass) {
    extend(Client, superClass);

    Client.prototype.known_services = {};

    Client.prototype.service_subscriptions = {};

    Client.prototype.service_connections = {};

    function Client(options) {
      if (options == null) {
        options = {};
      }
      Object.assign(this, options);
      this.connectToRegistry();
    }

    Client.prototype.connectToRegistry = function() {
      this.registry_connection = new Connection({
        proto: this.registry_proto || REGISTRY_PROTO,
        host: this.registry_host || REGISTRY_HOST,
        port: this.registry_port || REGISTRY_PORT,
        service: {
          id: 'registry~0',
          name: 'registry'
        }
      });
      return this.registry_connection.on('connect', this.registryConnected.bind(this));
    };

    Client.prototype.registryConnected = function() {
      this.connected_to_registry = true;
      this.registry_connection.subscribe('register', this.registeredService.bind(this));
      return this.registry_connection.subscribe('deregister', this.deregisteredService.bind(this));
    };

    Client.prototype.registeredService = function(err, new_service) {
      var base, name;
      if (VERBOSE > 1) {
        log.d('[Client.registry_connection.register]', new_service);
      }
      (base = this.known_services)[name = new_service.name] || (base[name] = {});
      return this.known_services[new_service.name][new_service.id] = new_service;
    };

    Client.prototype.deregisteredService = function(err, old_service) {
      var known, ref, subscriptions;
      if (VERBOSE > 1) {
        log.d('[Client.registry_connection.deregister]', old_service);
      }
      delete this.service_connections[old_service.name];
      if (known = (ref = this.known_services[old_service.name]) != null ? ref[old_service.id] : void 0) {
        delete this.known_services[old_service.name][old_service.id];
      }
      if (subscriptions = this.service_subscriptions[old_service.name]) {
        return subscriptions.filter(function(s) {
          return s.service === old_service.id;
        }).forEach((function(_this) {
          return function(subscription) {
            return _this.resubscribe(subscription);
          };
        })(this));
      }
    };

    Client.prototype.remote = function() {
      var args, cb, i, method, service;
      service = arguments[0], method = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), cb = arguments[i++];
      log.d("[Client.remote] " + service + "." + method + "(" + args + ")");
      return this.getConnection(service, (function(_this) {
        return function(err, connection) {
          if (connection != null) {
            return connection.method.apply(connection, [method].concat(slice.call(args), [cb]));
          } else {
            log.e('[Client.remote] No connection');
            return cb('No connection');
          }
        };
      })(this));
    };

    Client.prototype.subscribe = function() {
      var args, cb, i, id, options, service, type;
      service = arguments[0], type = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), cb = arguments[i++];
      if (arguments.length === 2) {
        options = arguments[0];
        cb = arguments[1];
        id = options.id, service = options.service, type = options.type, args = options.args;
      } else {
        id = helpers.randomString();
      }
      if (!this.connected_to_registry) {
        setTimeout(((function(_this) {
          return function() {
            return _this.subscribe({
              id: id,
              service: service,
              type: type,
              args: args
            }, cb);
          };
        })(this)), 500);
        return;
      }
      return this.getConnection(service, (function(_this) {
        return function(err, connection) {
          var _subscribe, base, s;
          if (connection != null) {
            log.s('[Client.subscribe]', service, type, args);
            s = connection.subscribe.apply(connection, [type].concat(slice.call(args), [cb]));
            s.cb = cb;
            (base = _this.service_subscriptions)[service] || (base[service] = []);
            return _this.service_subscriptions[service].push(s);
          } else {
            log.e('[Client.subscribe] No connection');
            _subscribe = function() {
              return _this.subscribe.apply(_this, [service, type].concat(slice.call(args), [cb]));
            };
            return setTimeout(_subscribe, 1500);
          }
        };
      })(this));
    };

    Client.prototype.resubscribe = function(subscription) {
      return this.getConnection(subscription.service, (function(_this) {
        return function(err, connection) {
          var _resubscribe;
          if (connection != null) {
            return connection.send(subscription);
          } else {
            log.e('[Client.resubscribe] no connection');
            _resubscribe = function() {
              return _this.resubscribe(subscription);
            };
            return setTimeout(_resubscribe, 1500);
          }
        };
      })(this));
    };

    Client.prototype.getService = function(service_id, cb) {
      return this.registry_connection.method('getService', service_id, cb);
    };

    Client.prototype.getConnection = function(service_id, cb) {
      var connection;
      if (service_id.match(/^registry/)) {
        return cb(null, this.registry_connection);
      } else if (connection = this.service_connections[service_id]) {
        return cb(null, connection);
      } else {
        return this.getService(service_id.split('~')[0], (function(_this) {
          return function(err, service) {
            if (err || (service == null)) {
              return cb(err);
            }
            connection = new Connection({
              host: service.host,
              port: service.port,
              service: service
            });
            _this.service_connections[service_id] = connection;
            connection.on('timeout', function() {
              var i, len, subscription, subscriptions;
              log.e("[Client.connection.on timeout] " + service_id);
              if (!connection.keepalive) {
                log.w("[Client.connection.on timeout] " + service_id + " Closing connection");
                delete _this.service_connections[service_id];
                if (subscriptions = _this.service_subscriptions[service_id]) {
                  for (i = 0, len = subscriptions.length; i < len; i++) {
                    subscription = subscriptions[i];
                    connection.unsubscribe(subscription.id);
                    setTimeout(function() {
                      return _this.subscribe(subscription.service, subscription.type, subscription.cb);
                    }, 1500);
                  }
                  delete _this.service_subscriptions[service_id];
                }
                return connection.close();
              }
            });
            return cb(null, connection);
          };
        })(this));
      }
    };

    return Client;

  })(EventEmitter);

  module.exports = Client;

}).call(this);
