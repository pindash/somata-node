// Generated by CoffeeScript 1.11.1
(function() {
  var CONNECTION_KEEPALIVE_MS, CONNECTION_LINGER_MS, CONNECTION_RETRY_MS, Client, Connection, EventEmitter, KEEPALIVE, REGISTRY_HOST, REGISTRY_PORT, REGISTRY_PROTO, VERBOSE, _, emitters, log, randomString,
    slice = [].slice;

  _ = require('underscore');

  Connection = require('./connection');

  log = helpers.log, randomString = helpers.randomString;

  EventEmitter = require('events').EventEmitter;

  emitters = require('./events');

  REGISTRY_PROTO = process.env.SOMATA_REGISTRY_PROTO || 'tcp';

  REGISTRY_HOST = process.env.SOMATA_REGISTRY_HOST || '127.0.0.1';

  REGISTRY_PORT = process.env.SOMATA_REGISTRY_PORT || 8420;

  VERBOSE = parseInt(process.env.SOMATA_VERBOSE || 0);

  KEEPALIVE = process.env.SOMATA_KEEPALIVE || true;

  CONNECTION_KEEPALIVE_MS = 6500;

  CONNECTION_LINGER_MS = 1500;

  CONNECTION_RETRY_MS = 2500;

  Client = (function() {
    function Client(options) {
      if (options == null) {
        options = {};
      }
      _.extend(this, options);
      this.events = new EventEmitter;
      this.service_subscriptions = {};
      this.service_connections = {};
      this.registry_connection = new Connection({
        proto: options.registry_proto || REGISTRY_PROTO,
        host: options.registry_host || REGISTRY_HOST,
        port: options.registry_port || REGISTRY_PORT,
        service_instance: {
          name: 'registry',
          id: 'registry'
        }
      });
      this.service_connections['registry'] = this.registry_connection;
      this.registry_connection.sendPing();
      this.registry_connection.once('connect', this.registryConnected.bind(this));
      emitters.exit.onExit((function(_this) {
        return function(cb) {
          log.w('Unsubscribing remote listeners...');
          _this.unsubscribeAll();
          return cb();
        };
      })(this));
      return this;
    }

    return Client;

  })();

  Client.prototype.call = function() {
    var args, cb, i, message_id, method_name, service_name;
    service_name = arguments[0], method_name = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), cb = arguments[i++];
    if (typeof cb !== 'function') {
      if (cb != null) {
        args.push(cb);
      }
      if (VERBOSE) {
        cb = function() {
          return log.w(service_name + ":" + method_name + " completed with no callback.");
        };
      } else {
        cb = null;
      }
    }
    message_id = helpers.randomString(16);
    this.getServiceConnection(service_name, (function(_this) {
      return function(err, service_connection) {
        if (err) {
          log.e(err);
          return cb(err);
        } else {
          return service_connection.sendMethod(message_id, method_name, args, cb);
        }
      };
    })(this));
    return message_id;
  };

  Client.prototype.remote = Client.prototype.call;

  Client.prototype.subscribe = function() {
    var args, cb, event_name, i, service_name, subscription_id;
    service_name = arguments[0], event_name = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), cb = arguments[i++];
    if (typeof cb !== 'function') {
      if (VERBOSE) {
        log.w(("[Client.subscribe] " + service_name + ":" + event_name + " not a function: ") + cb);
      }
      args.push(cb);
      cb = function() {
        return log.w(service_name + ":" + event_name + " event received with no callback.");
      };
    }
    subscription_id = service_name + ":" + event_name;
    if (args.length) {
      subscription_id += "(" + (args.join(', ')) + ")";
    }
    subscription_id += randomString(4);
    this._subscribe.apply(this, [subscription_id, service_name, event_name].concat(slice.call(args), [cb]));
    return subscription_id;
  };

  Client.prototype._subscribe = function() {
    var _subscribe, args, cb, event_name, i, me, service_name, subscription_id;
    subscription_id = arguments[0], service_name = arguments[1], event_name = arguments[2], args = 5 <= arguments.length ? slice.call(arguments, 3, i = arguments.length - 1) : (i = 3, []), cb = arguments[i++];
    _subscribe = (function(_this) {
      return function() {
        return _this._subscribe.apply(_this, [subscription_id, service_name, event_name].concat(slice.call(args), [cb]));
      };
    })(this);
    me = this;
    return me.getServiceConnection(service_name, function(err, service_connection) {
      var service_instance, subscription;
      if ((service_connection != null) && !service_connection.closing) {
        if (!service_connection.last_ping && service_connection.service_instance.heartbeat !== 0) {
          service_connection.sendPing();
        }
        service_instance = service_connection.service_instance;
        if (VERBOSE) {
          log.i("[Client.subscribe] " + service_connection.id + " : " + event_name);
        }
        subscription = service_connection.sendSubscribe(subscription_id, event_name, args, cb);
        subscription.name = service_name;
        subscription.instance = service_connection.service_instance;
        subscription.instance_id = service_connection.id;
        subscription.connection = service_connection;
        me.service_subscriptions[subscription_id] = subscription;
        return subscription.connection.once('failure', function() {
          if (subscription = me.service_subscriptions[subscription_id]) {
            if (VERBOSE) {
              log.e("[Client.subscribe.on 'failure'] " + subscription_id);
            }
            delete subscription.connection.pending_responses[subscription_id];
            subscription.connection.closing = true;
            subscription.connection.close();
            return _subscribe();
          }
        });
      } else {
        if (VERBOSE) {
          log.w("[Client.subscribe] Going to retry subscription to " + service_name);
        }
        return setTimeout(_subscribe, 1500);
      }
    });
  };

  Client.prototype.on = Client.prototype.subscribe;

  Client.prototype.unsubscribe = function(_sub_id) {
    return _.chain(this.service_subscriptions).pairs().filter(function(pair) {
      return pair[0] === _sub_id;
    }).map((function(_this) {
      return function(pair, _cb) {
        var sub, sub_id;
        sub_id = pair[0], sub = pair[1];
        sub.connection.sendUnsubscribe(sub_id, sub.type);
        return delete _this.service_subscriptions[sub_id];
      };
    })(this));
  };

  Client.prototype.unsubscribeAll = function() {
    return _.pairs(this.service_subscriptions).map((function(_this) {
      return function(arg, _cb) {
        var sub, sub_id;
        sub_id = arg[0], sub = arg[1];
        return _this.getServiceConnection(sub.instance.name, function(err, service_connection) {
          return service_connection.sendUnsubscribe(sub_id, sub.type);
        });
      };
    })(this));
  };

  Client.prototype.bindRemote = function() {
    var bound_args, ref;
    bound_args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return (ref = this.remote).bind.apply(ref, [this].concat(slice.call(bound_args)));
  };

  Client.prototype.bindService = function(service_name) {
    var _boundRemote, service_obj;
    service_obj = {};
    _boundRemote = this.remote.bind(this, service_name);
    this.getServiceInstance(service_name, function(err, service_instance) {
      if (service_instance != null) {
        return service_instance.methods.map(function(method_name) {
          return service_obj[method_name] = function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return _boundRemote.apply(null, [method_name].concat(slice.call(args)));
          };
        });
      }
    });
    return service_obj;
  };

  Client.prototype.getServiceInstance = function(service_name, cb) {
    return this.registry_connection.sendMethod(null, 'getService', [service_name], cb);
  };

  Client.prototype.getServiceConnection = function(service_name, cb) {
    var service_connection;
    if (service_connection = this.service_connections[service_name]) {
      cb(null, service_connection);
      return;
    }
    return this.getServiceInstance(service_name, (function(_this) {
      return function(err, service_instance) {
        var host, port, proto, service_id;
        if (err) {
          return cb(err);
        }
        service_id = service_instance.id;
        if (VERBOSE) {
          log.i("New connection to " + service_id);
        }
        proto = service_instance.proto, port = service_instance.port, host = service_instance.host;
        if ((host == null) || host === '0.0.0.0') {
          host = _this.registry_connection.host;
        }
        service_connection = new Connection({
          service_id: service_id,
          proto: proto,
          port: port,
          host: host,
          service_instance: service_instance
        });
        service_connection.on('failure', function() {
          var ref;
          if (((ref = (service_connection = _this.service_connections[service_name])) != null ? ref.id : void 0) === service_instance) {
            if (VERBOSE) {
              log.w("[connection.on failure] " + service_instance.id);
            }
            _this.closeConnection(service_instance);
            return _this.resubscribe(service_instance.id);
          }
        });
        _this.service_connections[service_name] = service_connection;
        return cb(null, service_connection);
      };
    })(this));
  };

  Client.prototype.registryConnected = function() {
    console.log('[Client.registryConnected]');
    this.subscribe('registry', 'deregister', this.deregistered.bind(this));
    return this.registry_connection.on('connect', this.registryReconnected.bind(this));
  };

  Client.prototype.registryReconnected = function() {
    return this.resubscribeAll();
  };

  Client.prototype.closeAllConnections = function() {
    var ref, results, service_connection, service_id;
    ref = this.service_connections;
    results = [];
    for (service_id in ref) {
      service_connection = ref[service_id];
      if (service_id !== 'registry') {
        results.push(this.closeConnection(service_connection.service_instance));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Client.prototype.deregistered = function(service_instance) {
    var service_connection;
    if (VERBOSE) {
      log.w("[deregistered] " + service_instance.id);
    }
    if (service_connection = this.service_connections[service_instance.name]) {
      this.closeConnection(service_instance);
      return this.resubscribe(service_instance.id);
    }
  };

  Client.prototype.resubscribe = function(service_id) {
    var needs_reconnect, ref, service_connection, service_name, subscription, subscription_id;
    needs_reconnect = false;
    ref = this.service_subscriptions;
    for (subscription_id in ref) {
      subscription = ref[subscription_id];
      if (subscription.instance.id === service_id) {
        needs_reconnect = true;
        break;
      }
    }
    if (needs_reconnect) {
      service_name = service_id.split('~')[0];
      service_connection = this.service_connections[service_name];
      if (service_connection != null) {
        return service_connection.emit('reconnect');
      }
    }
  };

  Client.prototype.resubscribeAll = function() {
    var need_reconnect, needs_reconnect, ref, results, service_connection, service_id, service_name, subscription, subscription_id;
    need_reconnect = {};
    ref = this.service_subscriptions;
    for (subscription_id in ref) {
      subscription = ref[subscription_id];
      service_id = subscription.instance.id;
      need_reconnect[service_id] = true;
    }
    results = [];
    for (service_id in need_reconnect) {
      needs_reconnect = need_reconnect[service_id];
      service_name = service_id.split('~')[0];
      service_connection = this.service_connections[service_name];
      results.push(service_connection.emit('reconnect'));
    }
    return results;
  };

  Client.prototype.closeConnection = function(service_instance) {
    var doClose, service_connection, service_name;
    service_name = service_instance.name;
    if (VERBOSE) {
      log.w("[closeConnection] " + service_instance.id);
    }
    if (service_connection = this.service_connections[service_name]) {
      service_connection.closing = true;
      doClose = (function(_this) {
        return function() {
          delete _this.service_connections[service_name];
          if (VERBOSE) {
            log.d("[closeConnection] Connection to " + service_instance.id + " closed after " + (CONNECTION_LINGER_MS / 1000) + "s");
          }
          return service_connection.close();
        };
      })(this);
      return setTimeout(doClose, CONNECTION_LINGER_MS);
    }
  };

  module.exports = Client;

}).call(this);
